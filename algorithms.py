# -*- coding: utf-8 -*-
"""Algorithms.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lM5vP3Z0uPf4g0onqwjSa8th6G8j-Ubk
"""

def minProductSubset(a, n):
    if (n == 1):
        return a[0]
 
    # Find count of negative numbers,
    # count of zeros, maximum valued
    # negative number, minimum valued
    # positive number and product
    # of non-zero numbers
    max_neg = float('-inf')
    min_pos = float('inf')
    count_neg = 0
    count_zero = 0
    prod = 1
    for i in range(0, n):
 
        # If number is 0, we don't
        # multiply it with product.
        if (a[i] == 0):
            count_zero = count_zero + 1
            continue
 
        # Count negatives and keep
        # track of maximum valued
        # negative.
        if (a[i] < 0):
            count_neg = count_neg + 1
            max_neg = max(max_neg, a[i])
 
        # Track minimum positive
        # number of array
        if (a[i] > 0):
            min_pos = min(min_pos, a[i])
 
        prod = prod * a[i]
        #print(prod)
 
    # If there are all zeros
    # or no negative number
    # present
    if (count_zero == n or (count_neg == 0
                            and count_zero > 0)):
        return 0
 
    # If there are all positive
    if (count_neg == 0):
        return min_pos
 
    # If there are even number of
    # negative numbers and count_neg
    # not 0
    if ((count_neg & 1) == 0 and
            count_neg != 0):
        print(count_neg & 1)
        # Otherwise result is product of
        # all non-zeros divided by
        # maximum valued negative.
        prod = int(prod / max_neg)
 
    return prod
 
 
# Driver code



a = [0, 1, 2, 4, 3]
n = len(a)
print(minProductSubset(a, n))

def min_value(a,n):
  if n==1:
    return a[0]
  
  if n==0:
    return None

  neg_count = 0
  prod = 1
  max_neg = float('-inf')
  min_pos = float('inf')
  count_0 = 0

  for i in range(0,n):
    if a[i]==0:
      count_0 = count_0 + 1
      min_pos = min(min_pos,a[i])
      continue

    elif a[i]<0:
      neg_count = neg_count + 1
      max_neg = max(a[i],max_neg)

    elif a[i]>0:
      min_pos = min(min_pos,a[i])

    prod = prod*a[i]

  if count_0 == n:
    return 0

  elif neg_count ==0:

    return min_pos 

  elif neg_count!=0 and (neg_count%2==0):
    prod = int(prod/max_neg)

  return prod

a = [-3,0,0,-3,0,-1]
n = len(a)
print(min_value(a, n))

"""-------------------------------------------------------------------------

Max product
"""

def max_prd(a,n):
  if n==0:
    return

  elif n==1:
    return a[0]

  max_neg = float('-inf')
  count_0 = 0
  count_neg = 0
  prod = 1
  for i in range(n):
    if a[i]==0:
      count_0 += 1
      continue

    if a[i]<0:
      count_neg +=1
      max_neg = max(a[i],max_neg)

    prod = prod*a[i]

  if count_0 == n:
    return 0

  elif count_0>1 and (count_neg==1 and (count_0 + count_neg) ==n):
    return 0

  elif count_neg%2!=0:
    prod = int(prod/max_neg)

  return prod

a = [1,0,0,0,0,0]
n = len(a)
print(max_prd(a, n))

"""--------------------------------------------------------------------------

**Max sum of K negations**
"""

def maxK(a,n,k):
  
  for i in range(k):
    minV = float('inf')
    for j in range(n):
      if a[j]<minV:
        minV = a[j]
        index = j

    a[index] = -a[index]

  sm = 0
  for l in range(n):
    sm = sm + a[l]
  return sm

a = [-2, 0, -6, 1, 2]
n = len(a)
k = 2
print(maxK(a,n,k))

"""--------------------------------------------------------------------------"""

a = [9,8,6,7,8]
a.sort() 
a

"""**Max sum of product of value and their index**"""

def mxpr(a,n):
  a.sort()
  sm = 0
  for i in range(n):
    sm = sm + a[i]*i

  return sm

a = [3, 5, 6, -1]
n = len(a)
print(mxpr(a,n))

"""-------------------------------------------------------------------------

**Maximum sum of increasing order elements from n arrays**[m*n]array
"""

def max_sum_n(a,n):
  sm_ar = []
  for i in range(n):
    a[i].sort(reverse=True)

  #a.sort(reverse=True)
  max_ele = float('-inf')
  for i in range(n):
    max_ele = max(max_ele,a[i][0])

  sm_ar.append(max_ele)
  cmax = max_ele
  #print(max_ele)

  for i in range(0,n-1):
    y = a[i+1]
    x = a[i]
    cmax = max(y)
    for j in range(len(x)):
      if x[j]==max_ele:
        break

      if x[j]<cmax:
        sm_ar.append(x[j])
        break

  #print(sm_ar)
  return sum(sm_ar)

a =  [[1, 1, 3, 1],
       [4, 2, 0, 1],
       [0, 5, 1, 8]]

n = len(a)
max_sum_n(a,n)

"""---------------------------------------------------------------------------

Maximize sum of consecutive differences in a circular array
"""

def maxSum(arr, n):
    sum = 0
 
    # Sorting the array
    arr.sort()
 
    # Subtracting a1, a2, a3,....., a(n/2)-1, an/2
    # twice and adding a(n/2)+1, a(n/2)+2, a(n/2)+3,.
    # ...., an - 1, an twice.
    for i in range(0, int(n / 2)) :
        sum -= (2 * arr[i])
        sum += (2 * arr[n - i - 1])
 
    return sum

arr = [4, 2, 1, 8]
n = len(arr)
print (maxSum(arr, n))

"""--------------------------------------------------------------------------

**Maximum height of triangular arrangement of array values**

**If we have maximum height h possible for our pyramid then (h*(h+1))/2 elements must be present in the array**
"""

def maxHeight(a,n):
  result = 1
  for i in range(1,n):
    y = (i*(i+1))/2

    if y<n:
      result = i

    else:
      break

  return result

a = [40, 100, 20, 30]
n = len(a)
print(maxHeight(a,n))



"""-----------------------------------------------------------------------------

**Partition into two subsets of lengths K and (N – k) such that the difference of sums is maximum**
"""

def maxDiff(a,n,k):
  a.sort(reverse=True)
  x = a[:n-k]
  y = [i for i in a if i not in x]
  max_dif = sum(x)-sum(y)
  return max_dif

arr = [ 8, 4, 5, 2, 10 ]
N = len(arr)
k = 2
print(maxDiff(arr, N, k))

"""---------------------------------------------

**Find the minimum sum of Products of two arrays of the same size, given that k modifications are allowed on the first array. In each modification, one array element of the first array can either be increased or decreased by 2**
"""

def minproduct(a,b,n,k):
 
    diff = 0
    res = 0
    for i in range(n):
 
        # Find product of current
        # elements and update result.
        pro = a[i] * b[i]
        res = res + pro
 
        # If both product and
        # b[i] are negative,
        # we must increase value
        # of a[i] to minimize result.
        if (pro < 0 and b[i] < 0):
            temp = (a[i] + 2 * k) * b[i]
 
        # If both product and
        # a[i] are negative,
        # we must decrease value
        # of a[i] to minimize result.
        elif (pro < 0 and a[i] < 0):
            temp = (a[i] - 2 * k) * b[i]
 
        # Similar to above two cases
        # for positive product.
        elif (pro > 0 and a[i] < 0):
            temp = (a[i] + 2 * k) * b[i]
        elif (pro > 0 and a[i] > 0):
            temp = (a[i] - 2 * k) * b[i]
 
        # Check if current difference
        # becomes higher
        # than the maximum difference so far.
        d = abs(pro - temp)
 
        if (d > diff):
            diff = d      
    return res - diff

def minSum(a,b,n,k):
  max_ = []
  for i in range(n):
    pr = abs(a[i]*b[i])
    max_.append(pr)

  mnIndex = max_.index(min(max_))

  if a[mnIndex]>0 and b[mnIndex]>0:
    a[mnIndex] = a[mnIndex]-2*k

  if a[mnIndex]>0 and b[mnIndex]<0:
    a[mnIndex] = a[mnIndex]+2*k

  if a[mnIndex]<0 and b[mnIndex]<0:
    a[mnIndex] = a[mnIndex]-2*k
  
  #print(a[mnIndex])

  sm = 0
  for i in range(n):
    sm = sm + a[i]*b[i]

  return sm

a = [ 2, 3, 4, 5, 4 ]
b = [ 3, 4, 2, 3, 2 ]
n = 5
k = 3
print(minSum(a,b,5,3))

"""--------------------------------------------------------------------------

**Given an array A[] of n-elements. We need to select two adjacent elements and delete the larger of them and store smaller of them to another array say B[]. We need to perform this operation till array A[] contains only single element. Finally, we have to construct the array B[] in such a way that total sum of its element is minimum. Print the total sum of array B[]**

**There is an easy trick to solve this question and that is always choose the smallest element of array A[] and its adjacent, delete the adjacent element and copy smallest one to array B[]. Again for next iteration we have same smallest element and any random adjacent element which is to be deleted. After n-1 operations all of elements of A[] got deleted except the smallest one and at the same time array B[] contains “n-1” elements and all are equal to smallest element of array A[]. 
Thus total sum of array B[] is equal to smallest *(n-1)**
"""

def sumSmall(a,n):
  minV = min(a)
  sumSm = minV*(n-1)
  return sumSm

A = [7, 2, 3, 4, 5, 6]
print(sumSmall(A,len(A)))

"""--------------------------------------------------------------------------

**Given an array and k, we need to find the minimum operations needed to make GCD of the array equal or multiple of k. Here an operation means either increment or decrements an array element by 1**
"""

def mingcd(a,k):
  sum = 0
  for i in range(len(a)):
    if a[i]>k:
      a[i] = a[i]-1
      sum = sum+1
    elif a[i]<k:
      a[i] = a[i]+1
      sum = sum + 1
    else:
      pass
      
  return sum

arr = [ 4, 5, 6 ]
    n = len(arr)
    k = 5
    print(mingcd(arr, k))

"""-------------------------------------------------------------------------

**Given two arrays a[] and b[] of equal length n. The task is to pair each element of array a to an element in array b, such that sum S of absolute differences of all the pairs is minimum**
"""

def sumabs(a,b,n):
  a.sort()
  b.sort()
  sum = 0
  for i in range(n):
    sum = sum + abs(a[i]-b[i])

  return sum

a = [4, 1, 8, 7]
b = [2, 3, 6, 5]
n = len(a)
 
print(sumabs(a, b, n))

"""---------------------------------------------

**Given an array of digits (values are from 0 to 9), find the minimum possible sum of two numbers formed from digits of the array. All digits of given array must be used to form the two numbers.**

**We can follow another approach also like this, as we need two numbers such that their sum is minimum, then we would also need two minimum numbers. If we arrange our array in ascending order then we can two digits that will form the smallest numbers, e.g., 2 3 4 5 6 8, now we can get two numbers starting from 2 and 3. First part is done now. Moving forward we have to form such that they would contain small digits, i.e. pick digits alternatively from array extend your two numbers. i.e. 246, 358. Now if we see analyze this, then we can pick even indexed numbers for num1 and an odd number for num2**
"""

def minsum(a,n):
  num1 = 0
  num2 = 0
  a.sort()
  for i in range(n):
    if i%2==0:
      num1 = num1*10 + a[i]
    else:
      num2 = num2*10 + a[i]

  return num1 + num2

arr = [5, 3, 0, 7, 4]
n = len(arr)
print("The required sum is",
             minsum(arr, n))

"""-------------------------------------------------------------------------

**Given two arrays of same size, we need to convert the first array into another with minimum operations. In an operation, we can either increment or decrement an element by one. Note that orders of appearance of elements do not need to be same.Here to convert one number into another we can add or subtract 1 from it**
"""

def minop(a,b,n):
  a.sort(reverse=True)
  b.sort(reverse=True)

  op = 0
  sum = 0
  for i in range(n):
    if a[i]>b[i] or a[i]<b[i]:
      sum = sum + 1

    else:
      pass
  return sum

a = [3, 1, 1]
b = [1, 2, 2]
n = len(a)
print(minop(a, b, n))

"""--------------------------------------------------------------------------

**Given two arrays, A and B, of equal size n, the task is to find the minimum value of A[0] * B[0] + A[1] * B[1] +…+ A[n-1] * B[n-1]. Shuffling of elements of arrays A and B is allowed**
"""

def minValue(a,b,n):
  a.sort()
  b.sort(reverse=True)
  sum = 0 
  for i in range(n):
    sum = sum + a[i]*b[i]

  return sum

A = [3, 1, 1]
B = [6, 5, 4]
n = len(A)
print (minValue(A, B, n))

"""---------------------------------------------

**Given a list of n integers containing numbers 1-n in a shuffled way and a integer K. N people are standing in a queue to play badminton. At first, the first two players in the queue play a game. Then the loser goes to the end of the queue, and the one who wins plays with the next person from the line, and so on. They play until someone wins k games consecutively. This player becomes the winner.**
"""

def findwinner(a,n,k):
  wins = 0
  best = a[0]
  i = 1
  while i in range(n):
    
    #print('a =',a)
    #print(best)
    if a[i]>best:
      a.remove(best)
      a.append(best)
      best = a[i]
      i = 0
      wins = 1
      #print(best)
      # if i==True:
      #   #print(i)
      #   wins = 1

    else:
      temp = a[i]
      a.remove(a[i])
      a.append(temp)
      i = 0
     # print(a)
      wins = wins + 1

    if wins>=k:
      return best

a = [4,3,2,1,5,9,7,0]
n = len(a)
k = 3
print(findwinner(a, n, k))

"""-------------------------------------------------------------------------

**A hotel manager has to process N advance bookings of rooms for the next season. His hotel has K rooms. Bookings contain an arrival date and a departure date. He wants to find out whether there are enough rooms in the hotel to satisfy the demand.**
"""

def checkAval(a,b,n,k):
  a.sort()
  b.sort()
  for i in range(n):
    if i+k<n and a[i+k]<b[i]:
      return 'No'

  return 'Yes'

arrival = [1, 2, 3]
departure = [2, 5, 4]
k = 1
n = len(arrival)
print(checkAval(arrival,departure,n,k))